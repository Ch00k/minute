diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/includes/database.sqlite.core-patches.inc drupal-sqlite/includes/database.sqlite.core-patches.inc
--- drupal-6.19/includes/database.sqlite.core-patches.inc	1970-01-01 01:00:00.000000000 +0100
+++ drupal-sqlite/includes/database.sqlite.core-patches.inc	2009-12-17 13:01:56.198625000 +0100
@@ -0,0 +1,92 @@
+<?php
+/**
+ * ======================================================================
+ * This file contains core query rewrite rules, applied to queries just
+ * before their execution.
+ *
+ * If you want to add custom patches for your additional modules,
+ * DO NOT ADD THEM HERE, CUSTOM PATCHES this file will be overwritten when
+ * you install a newer Drupal-SQLite release.
+ *
+ * Add your rewrite rules into a file named "database.sqlite.user-patches.inc"
+ * (see "database.sqlite.user-patches.sample" for an example).
+ * Your patches will be applied AFTER the core ones.
+ * ======================================================================
+ */
+function _sqlite_core_rewrite_query(&$query)
+{
+
+  /**
+   * --------------------------------------------------
+   * Module: actions (core)
+   * --------------------------------------------------
+   * Patch for "INSERT INTO" with DEFAULT values.
+   * Will change:
+   * INSERT INTO {action_aid} VALUES (default)
+   * to:
+   * INSERT INTO {action_aid} DEFAULT VALUES
+   */
+  if ((substr($query, 0, 12) === 'INSERT INTO ') && stripos($query, ' VALUES (default)') > 0){
+    $query = str_ireplace(' VALUES (default)', ' DEFAULT VALUES', $query);
+    return;
+  }
+
+
+  /**
+   * --------------------------------------------------
+   * Module: comments (core)
+   * --------------------------------------------------
+   * comments module uses a query+subquery to sort comments.
+   * Will change:
+   * (SELECT thread FROM comments...
+   * to:
+   * SELECT * FROM (SELECT thread FROM comments...
+   */
+  if (substr($query, 0, 28) === '(SELECT thread FROM comments') {
+    $query = 'SELECT * FROM ' . $query;
+    return;
+  }
+
+
+  /**
+   * --------------------------------------------------
+   * Module: devel (not a core module but largely used)
+   * --------------------------------------------------
+   * devel module uses an extension of MySQL to insert several rows at once.
+   * Will change:
+   * INSERT INTO [table] VALUES (<values 1>),(<values 2>),(<values 3>)
+   * to:
+   * INSERT INTO [table] SELECT <values 1> UNION ALL <values 2> UNION ALL <values 3>
+   */
+  if(variable_get('devel_store_queries', 0)) {
+    $devel_workaround_string = 'INSERT INTO devel_times (qid, time) VALUES (';
+    $devel_workaround_length = strlen($devel_workaround_string);
+    if (substr($query, 0, $devel_workaround_length) == $devel_workaround_string)
+    {
+      $query = 'INSERT INTO devel_times (qid, time) SELECT '
+             . str_replace('),(', ' UNION ALL SELECT ', substr($query, $devel_workaround_length, -1));
+      return;
+    }
+  }
+
+  /**
+   * --------------------------------------------------
+   * Module: cache and update (core)
+   * --------------------------------------------------
+   * These two modules, starting from 6.15, use the "TRUNCATE TABLE {table}" SQL command
+   * instead of the old "DELETE FROM {table}".
+   * SQLite does not support TRUNCATE, so will change it back to DELETE FROM.
+   * Will change:
+   * TRUNCATE TABLE
+   * to:
+   * DELETE FROM
+   */
+  if (substr($query, 0, 15) === 'TRUNCATE TABLE ') {
+    $query = str_replace('TRUNCATE TABLE ', 'DELETE FROM ', $query);
+    return;
+  }
+
+/**
+ * end of the function
+ */
+}
diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/includes/database.sqlite.inc drupal-sqlite/includes/database.sqlite.inc
--- drupal-6.19/includes/database.sqlite.inc	1970-01-01 01:00:00.000000000 +0100
+++ drupal-sqlite/includes/database.sqlite.inc	2010-06-10 21:11:01.897875000 +0200
@@ -0,0 +1,1411 @@
+<?php
+// $Id:
+
+/**
+ * Database interface code for SQLite
+ * Based on the original database.mysql.inc and database.mysql-common.inc
+ *
+ * This file is part of Drupal-SQLite by CoolSoft,
+ * a patched Drupal 6 version that works with a SQLite database layer.
+ *
+ * @author Claudio Nicora (coolsoft@altervista.org)
+ * @see http://coolsoft.altervista.org/drupal-sqlite
+ */
+
+/**
+ * Minimum supported version of SQLite.
+ * It is defined here instead of 'modules/system/system.module'
+ * to prevent it being overwritten by future Drupal updates.
+ */
+define('DRUPAL_MINIMUM_SQLITE',  '3.0.0');
+
+/**
+ * Suffix for index names.
+ */
+define('SQLITE_INDEX_NAME_SUFFIX', '_IDX');
+
+/**
+ * Include code to to patch core queries before they are executed.
+ * This is done because I want to keep _db_query() as clean as possible.
+ */
+require('database.sqlite.core-patches.inc');
+
+/**
+ * Optional user file where user can add patches for external module queries.
+ * I don't want Drupal-SQLite to include query patches for each
+ * existing module, so put yours here
+ * (see "database.sqlite.user-patches.sample" as a sample).
+ */
+@include('database.sqlite.user-patches.inc'); // @ for "no warning"
+
+/**
+ * Report database status.
+ */
+function db_status_report($phase) {
+  $t = get_t();
+
+  $version = db_version();
+
+  $form['sqlite'] = array(
+    'title' => $t('SQLite database'),
+    'value' => $version,
+  );
+
+  if (version_compare($version, DRUPAL_MINIMUM_SQLITE) < 0) {
+    $form['sqlite']['severity'] = REQUIREMENT_ERROR;
+    $form['sqlite']['description'] = $t('Your SQLite library is too old. Drupal requires at least version %version.', array('%version' => DRUPAL_MINIMUM_SQLITE));
+  }
+
+  return $form;
+}
+
+
+/**
+ * Returns the version of the database server currently in use.
+ *
+ * @return string Database server version
+ */
+function db_version() {
+  return db_result(db_query("SELECT SQLITE_VERSION()"));
+}
+
+
+/**
+ * Initialize a database connection.
+ */
+function db_connect($url) {
+
+  // parse the DB url
+  $url = parse_url(urldecode($url));
+
+  // Check if PDO SQLite support is present in PHP.
+  if (!(class_exists('PDO') && extension_loaded('pdo_sqlite'))) {
+    _db_error_page('Unable to use the SQLite database because the pdo_sqlite extension for PHP is not installed. Check your php.ini to see how you can enable it.');
+  }
+
+  // Build pdo_sqlite connection string.
+  if (!isset($url['path'])) {
+    throw new Exception("db_url not set in settings.php");
+  } else {
+    // removes the leading "/"
+    $dsn = 'sqlite:' . substr($url['path'],1);
+  }
+
+  $driver_options = array(
+    // Throw a PDOException and set its properties to reflect the error code
+    // and error information (will change after connection)
+    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,    // will change later
+    //  Leave column names as returned by the database driver.
+    PDO::ATTR_CASE => PDO::CASE_NATURAL,
+    // Timeout
+    PDO::ATTR_TIMEOUT => 20,
+  );
+
+  try {
+    $connection = new PDO($dsn, '', '', $driver_options);
+  } catch (PDOExecption $e) {
+    _db_error_page($e->getMessage());
+    return false;
+  }
+
+  // reset PDO SQLite error mode
+  $connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);
+
+  // Modify the operation of the SQLite library
+  $connection->exec('PRAGMA synchronous=OFF');
+  $connection->exec('PRAGMA short_column_names=1');
+  $connection->exec('PRAGMA temp_store=MEMORY');
+  $connection->exec('PRAGMA cache_size=4000');
+  $connection->exec('PRAGMA count_changes=0');
+  $connection->exec('PRAGMA encoding="UTF-8"');
+
+
+  /*
+   * From PHP documentation:
+   * This function is EXPERIMENTAL. The behaviour of this function,
+   * its name, and surrounding documentation may change without notice
+   * in a future release of PHP. This function should be used at your own risk.
+   * http://it2.php.net/manual/en/function.pdo-sqlitecreatefunction.php
+   * so it's better to test it.
+   */
+  if(!method_exists($connection, 'sqliteCreateFunction')){
+    ${DB_ERROR} = TRUE;
+    trigger_error('Error while adding custom SQLite functions.<br />PDO::sqliteCreateFunction method is missing.', E_USER_WARNING);
+  } else {
+    // register functions which are not built-in in SQLite
+    $connection->sqliteCreateFunction('concat', '_sqlite_concat');
+    $connection->sqliteCreateFunction('substring', '_sqlite_substring');
+    $connection->sqliteCreateFunction('greatest', '_sqlite_greatest');
+    $connection->sqliteCreateFunction('rand', '_sqlite_rand');
+    $connection->sqliteCreateFunction('if', '_sqlite_if', 3);
+    $connection->sqliteCreateFunction('year', '_sqlite_year', 1);
+    $connection->sqliteCreateFunction('month', '_sqlite_month', 1);
+    $connection->sqliteCreateFunction('FROM_UNIXTIME', '_sqlite_from_unix_timestamp', 1);
+    $connection->sqliteCreateFunction('pow', '_sqlite_pow', 2);
+    $connection->sqlitecreateFunction('MD5', '_sqlite_md5', 1);
+    $connection->sqlitecreateFunction('DATE_FORMAT', '_sqlite_dateformat', 2);
+  }
+
+  if(!method_exists($connection, 'sqliteCreateAggregate')){
+    ${DB_ERROR} = TRUE;
+    trigger_error('Error while adding custom SQLite functions.<br />PDO::sqliteCreateAggregate method is missing.', E_USER_WARNING);
+  } else {
+    // register functions which are not built-in in SQLite
+    $connection->sqliteCreateAggregate('COALESCE', '_sqlite_coalesce_step', '_sqlite_coalesce_finalize');
+    $connection->sqliteCreateAggregate('STDDEV', '_sqlite_stddev_step', '_sqlite_stddev_finalize');
+  }
+
+  return $connection;
+}
+
+
+/**
+ * Helper function for db_query().
+ */
+function _db_query($query, $debug = 0) {
+
+  global $active_db, $last_result, $queries, $user;
+
+  // Expand $query if it is in array format.
+  $args = array();
+  if (is_array($query)) {
+    $args = $query['args'];
+    $query = $query['query'];
+
+    // Check if locator exists in query, or else unset it.
+    foreach ($args as $key => $value) {
+      if (!is_array($args[$key]) || !isset($args[$key]['locator']) || !strstr($query, $args[$key]['locator'])) {
+        unset($args[$key]);
+      }
+    }
+  }
+
+  /**
+   * Run core query rewrite rules, from file
+   * 'database.sqlite.core-patches.inc'.
+   * This is done because I want to keep _db_query() as clean as possible.
+   */
+  _sqlite_core_rewrite_query($query);
+
+  /**
+   * Optional user function with custom rewrite rules, from
+   * 'database.sqlite.user-patches.inc' file.
+   * I don't want Drupal-SQLite to include query patches for each
+   * existing module, so put yours there.
+   * Use 'database.sqlite.core-patches.sample' as example.
+   * $query is a String parameter containing the SQL query ready to be executed.
+   */
+  if (function_exists('_sqlite_user_rewrite_query')) {
+     _sqlite_user_rewrite_query($query);
+  }
+
+  // developer module
+  if (variable_get('dev_query', 0)) {
+    list($usec, $sec) = explode(' ', microtime());
+    $timer = (float)$usec + (float)$sec;
+    // If devel.module query logging is enabled, prepend a comment with the username and calling function
+    // to the SQL string. This is useful when running mysql's SHOW PROCESSLIST to learn what exact
+    // code is issueing the slow query.
+    $bt = debug_backtrace();
+    // t() may not be available yet so we don't wrap 'Anonymous'.
+    $name = $user->uid ? $user->name : variable_get('anonymous', 'Anonymous');
+    // str_replace() to prevent SQL injection via username or anonymous name.
+    $name = str_replace(array('*', '/'), '', $name);
+    $query = '/* '. $name .' : '. $bt[2]['function'] .' */ '. $query;
+  }
+
+  // prepare a statement
+  $last_result = $stmt = $active_db->prepare($query);
+  if(!$stmt){
+    $error = $active_db->errorInfo();
+    if (is_array($error) && isset($error[2])) {
+      // Indicate to drupal_error_handler that this is a database error.
+      ${DB_ERROR} = TRUE;
+      trigger_error(check_plain($error[2]) . '<br />query: ' . check_plain($query), E_USER_WARNING);
+    }
+    return FALSE;
+  }
+
+  if (count($args)) {
+    foreach ($args as $key => $value) {
+      if (isset($args[$key]['type'])) {
+        $stmt->bindValue($args[$key]['locator'], $args[$key]['data'], $args[$key]['type']);
+      }
+      else {
+        $stmt->bindValue($args[$key]['locator'], $args[$key]['data']);
+      }
+    }
+  }
+
+  // execute the statement.
+  $result = $stmt->execute();
+  if ($stmt->errorCode() !== '00000') {
+    ${DB_ERROR} = TRUE;
+    trigger_error(check_plain($error[2]) . '<br />query: ' . check_plain($query), E_USER_WARNING);
+    return FALSE;
+  }
+
+  if (variable_get('dev_query', 0)) {
+    $query = $bt[2]['function'] ."\n". $query;
+    list($usec, $sec) = explode(' ', microtime());
+    $stop = (float)$usec + (float)$sec;
+    $diff = $stop - $timer;
+    $queries[] = array($query, $diff);
+  }
+
+  if ($debug) {
+    $error = $active_db->errorInfo();
+    print '<p>query: '. $query .'<br />error:'. $error[2] .'</p>';
+  }
+
+  return $last_result;
+}
+
+
+/**
+ * Fetch one result row from the previous query as an object.
+ *
+ * @param $result
+ *   A database query result resource, as returned from db_query().
+ * @return
+ *   An object representing the next row of the result, or FALSE. The attributes
+ *   of this object are the table fields selected by the query.
+ */
+function db_fetch_object($result) {
+  if ($result) {
+    $object = $result->fetch(PDO::FETCH_OBJ);
+    if (!is_object($object) || !$object) return FALSE;
+
+    /**
+     * Fix for short_column_names not returned
+     * by SQLite when runnung JOINed queries.
+     * Will retrieve object properties (record columns) and,
+     * if some of them contains a '.' in its name,
+     * will create an "alias" property without the dot.
+     **/
+    $query = $result->queryString;
+    if (! property_exists($result, 'fix_short_column_names')) {
+      $result->fix_short_column_names =
+        (strpos($query, 'JOIN')     !== FALSE) &&
+        (strpos($query, 'GROUP BY') !== FALSE);
+    }
+
+    if ($result->fix_short_column_names) {
+    $objectProps = get_object_vars($object);
+    foreach ($objectProps as $propName => $value) {
+      $pos = strpos($propName, '.');
+      if($pos !== FALSE) {
+        // will create alias only if a property
+        // with the same name does not already exist
+        $aliasProp = substr($propName, $pos+1);
+        if(!array_key_exists($aliasProp, $objectProps)) {
+          $object->$aliasProp = $value;
+        }
+      }
+    }
+  }
+    return $object;
+  }
+  return FALSE;
+}
+
+
+/**
+ * Fetch one result row from the previous query as an array.
+ *
+ * @param $result
+ *   A database query result resource, as returned from db_query().
+ * @return
+ *   An associative array representing the next row of the result, or FALSE.
+ *   The keys of this object are the names of the table fields selected by the
+ *   query, and the values are the field values for this result row.
+ */
+function db_fetch_array($result) {
+  if ($result) {
+    $array = $result->fetch(PDO::FETCH_ASSOC);
+    return isset($array) ? $array : FALSE;
+  }
+  return FALSE;
+}
+
+
+/**
+ * Return an individual result field from the previous query.
+ *
+ * Only use this function if exactly one field is being selected; otherwise,
+ * use db_fetch_object() or db_fetch_array().
+ *
+ * @param $result
+ *   A database query result resource, as returned from db_query().
+ * @return
+ *   The resulting field or FALSE.
+ */
+function db_result($result) {
+  if ($result) {
+    $array = $result->fetch(PDO::FETCH_NUM);
+    return isset($array[0]) ? $array[0] : FALSE;
+  }
+  return FALSE;
+}
+
+
+/**
+ * Determine whether the previous query caused an error.
+ */
+function db_error() {
+  global $last_result;
+  if($last_result) {
+    $error = $last_result->errorInfo();
+    if (is_array($error) && isset($error[2])) {
+      return $error[2];
+    }
+  }
+}
+
+
+/**
+ * Determine the number of rows changed by the preceding query.
+ */
+function db_affected_rows() {
+  global $last_result;
+  if ($last_result)
+    return $last_result->rowCount();
+   else
+    return 0;
+}
+
+
+/**
+ * Runs a limited-range query in the active database.
+ *
+ * Use this as a substitute for db_query() when a subset of the query is to be
+ * returned.
+ * User-supplied arguments to the query should be passed in as separate parameters
+ * so that they can be properly escaped to avoid SQL injection attacks.
+ *
+ * @param $query
+ *   A string containing an SQL query.
+ * @param ...
+ *   A variable number of arguments which are substituted into the query
+ *   using printf() syntax. The query arguments can be enclosed in one
+ *   array instead.
+ *   Valid %-modifiers are: %s, %d, %f, %b (binary data, do not enclose
+ *   in '') and %%.
+ *
+ *   NOTE: using this syntax will cast NULL and FALSE values to decimal 0,
+ *   and TRUE values to decimal 1.
+ *
+ * @param $from
+ *   The first result row to return.
+ * @param $count
+ *   The maximum number of result rows to return.
+ * @return
+ *   A database query result resource, or FALSE if the query was not executed
+ *   correctly.
+ */
+function db_query_range($query) {
+  $args = func_get_args();
+  $count = array_pop($args);
+  $from = array_pop($args);
+  array_shift($args);
+
+  $query .= ' LIMIT '. (int) $count .' OFFSET '. (int) $from;
+  if (isset($args[0]) and is_array($args[0])) { // 'All arguments in one array' syntax
+    $args = $args[0];
+  }
+  return db_query($query, $args);
+}
+
+
+/**
+ * Runs a SELECT query and stores its results in a temporary table.
+ *
+ * Use this as a substitute for db_query() when the results need to stored
+ * in a temporary table. Temporary tables exist for the duration of the page
+ * request.
+ * User-supplied arguments to the query should be passed in as separate parameters
+ * so that they can be properly escaped to avoid SQL injection attacks.
+ *
+ * Note that if you need to know how many results were returned, you should do
+ * a SELECT COUNT(*) on the temporary table afterwards. db_affected_rows() does
+ * not give consistent result across different database types in this case.
+ *
+ * @param $query
+ *   A string containing a normal SELECT SQL query.
+ * @param ...
+ *   A variable number of arguments which are substituted into the query
+ *   using printf() syntax. The query arguments can be enclosed in one
+ *   array instead.
+ *   Valid %-modifiers are: %s, %d, %f, %b (binary data, do not enclose
+ *   in '') and %%.
+ *
+ *   NOTE: using this syntax will cast NULL and FALSE values to decimal 0,
+ *   and TRUE values to decimal 1.
+ *
+ * @param $table
+ *   The name of the temporary table to select into. This name will not be
+ *   prefixed as there is no risk of collision.
+ * @return
+ *   A database query result resource, or FALSE if the query was not executed
+ *   correctly.
+ */
+function db_query_temporary($query) {
+  $args = func_get_args();
+  $tablename = array_pop($args);
+  array_shift($args);
+
+  $query = preg_replace('/^SELECT/i', 'CREATE TEMPORARY TABLE '. $tablename .' AS SELECT', $query);
+  if (isset($args[0]) and is_array($args[0])) { // 'All arguments in one array' syntax
+    $args = $args[0];
+  }
+  return db_query($query, $args);
+}
+
+
+/**
+ * Returns a properly formatted Binary Large Object value.
+ *
+ * @param $data
+ *   Data to encode.
+ * @return
+ *  Encoded data.
+ */
+function db_encode_blob($data) {
+  // base64_encode is the better choice to store a BLOB in a SQLite field
+  // PDO->quote() is not working well since it stops at the first \0 byte
+  $res = "'" . base64_encode($data) . "'";
+  return $res;
+}
+
+
+/**
+ * Returns text from a Binary Large Object value.
+ *
+ * @param $data
+ *   Data to decode.
+ * @return
+ *  Decoded data.
+ */
+function db_decode_blob($data) {
+  return base64_decode($data);
+}
+
+
+/**
+ * Prepare user input for use in a database query, preventing SQL injection attacks.
+ */
+function db_escape_string($text) {
+  global $active_db;
+  $res = $active_db->quote($text, PDO::PARAM_STR);
+  // removes ' as prefix/suffix
+  if(strlen($res) >= 2)
+  return substr($res, 1, strlen($res)-2);
+  else
+  return $res;
+}
+
+
+/**
+ * Lock a table.
+ */
+function db_lock_table($table) {
+  global $active_db;
+  $active_db->beginTransaction();
+}
+
+
+/**
+ * Unlock all locked tables.
+ */
+function db_unlock_tables() {
+  global $active_db;
+  $active_db->commit();
+}
+
+
+/**
+ * Check if a table exists.
+ */
+function db_table_exists($table) {
+  return (bool) db_result(db_query("SELECT COUNT(*) FROM SQLITE_MASTER WHERE TBL_NAME LIKE '{". db_escape_table($table) ."}'"));
+}
+
+
+/**
+ * Check if a column exists in the given table.
+ */
+function db_column_exists($table, $column) {
+  $result = db_query("PRAGMA TABLE_INFO('{". db_escape_table($table) ."}')");
+  while ($row = db_fetch_array($result)) {
+    if ($row['name'] == $column) {
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
+
+/**
+ * Runs a basic query in the active database.
+ *
+ * User-supplied arguments to the query should be passed in as separate
+ * parameters so that they can be properly escaped to avoid SQL injection
+ * attacks.
+ *
+ * @param $query
+ *   A string containing an SQL query.
+ * @param ...
+ *   A variable number of arguments which are substituted into the query
+ *   using printf() syntax. Instead of a variable number of query arguments,
+ *   you may also pass a single array containing the query arguments.
+ *
+ *   Valid %-modifiers are: %s, %d, %f, %b (binary data, do not enclose
+ *   in '') and %%.
+ *
+ *   NOTE: using this syntax will cast NULL and FALSE values to decimal 0,
+ *   and TRUE values to decimal 1.
+ *
+ * @return
+ *   A database query result resource, or FALSE if the query was not
+ *   executed correctly.
+ */
+function db_query($query) {
+
+  $args = func_get_args();
+  array_shift($args);
+  $query = db_prefix_tables($query);
+  if (isset($args[0]) and is_array($args[0])) { // 'All arguments in one array' syntax
+    $args = $args[0];
+  }
+  _db_query_callback($args, TRUE);
+  $query = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $query);
+  return _db_query($query);
+}
+
+
+/**
+ * Generate SQL to create a new table from a Drupal schema definition.
+ *
+ * @param $name
+ *   The name of the table to create.
+ * @param $table
+ *   A Schema API table definition array.
+ * @return
+ *   An array of SQL statements to create the table.
+ */
+function db_create_table_sql($name, $table) {
+  $sql_fields = array();
+  foreach ($table['fields'] as $field_name => $field) {
+    if ($field['type'] == 'serial' && isset($table['primary key']) && in_array($field_name, $table['primary key'])) {
+      unset($table['primary key']);
+    }
+    $sql_fields[] = _db_create_field_sql($field_name, _db_process_field($field));
+  }
+
+  $sql_keys = array();
+  if (isset($table['primary key']) && is_array($table['primary key'])) {
+    $sql_keys[] = 'PRIMARY KEY (['. implode('], [', $table['primary key']) .'])';
+  }
+  if (isset($table['unique keys']) && is_array($table['unique keys'])) {
+    foreach ($table['unique keys'] as $key_name => $key) {
+      $sql_keys[] = 'UNIQUE (['. implode('], [', $key) .'])';
+    }
+  }
+
+  $sql = "CREATE TABLE [{". $name ."}] (\n\t";
+  $sql .= implode(",\n\t", $sql_fields);
+  if (count($sql_keys) > 0) {
+    $sql .= ",\n\t";
+  }
+  $sql .= implode(",\n\t", $sql_keys);
+  $sql .= "\n)";
+  $statements[] = $sql;
+
+  if (isset($table['indexes']) && is_array($table['indexes'])) {
+    foreach ($table['indexes'] as $key_name => $key) {
+      $statements[] = _db_create_index_sql($name, $key_name, $key);
+    }
+  }
+
+  // In case of SQLite, use transaction to ensure atomic CREATE TABLE.
+  return array_merge(
+    array('BEGIN'),
+    $statements,
+    array('COMMIT')
+  );
+}
+
+
+/**
+ *
+ * @param $table
+ * Table name
+ * @param $name
+ * Name of the index (will be composed as TABLENAME_INDEXNAME_IDX
+ * @param $fields
+ * Fields of this index
+ * @return unknown_type
+ */
+function _db_create_index_sql($table, $name, $fields, $unique = false) {
+  if($unique) {
+    $res = 'CREATE UNIQUE INDEX ';
+  } else {
+    $res = 'CREATE INDEX ';
+  }
+  $res .= $table . '_'
+        . $name . SQLITE_INDEX_NAME_SUFFIX . ' ON '
+        . $table .' (' . _db_create_key_sql($fields) .')';
+  return $res;
+}
+
+
+/**
+ * @param $table
+ * Table name
+ * @param $name
+ * Name of the index (will be composed as TABLENAME_INDEXNAME_IDX
+ * @return unknown_type
+ */
+function _db_drop_index_sql($table, $name) {
+  return 'DROP INDEX IF EXISTS '
+        . $table . '_' . $name . SQLITE_INDEX_NAME_SUFFIX;
+}
+
+
+/**
+ * Set database-engine specific properties for a field.
+ *
+ * @param $field
+ *   A field description array, as specified in the schema documentation.
+ */
+function _db_process_field($field) {
+  if (!isset($field['size'])) {
+    $field['size'] = 'normal';
+  }
+
+  // Set the correct database-engine specific datatype.
+  if (!isset($field['sqlite_type'])) {
+    $map = db_type_map();
+    $field['sqlite_type'] = $map[$field['type'] .':'. $field['size']];
+  }
+
+  if ($field['type'] == 'serial') {
+    $field['auto_increment'] = TRUE;
+  }
+
+  if ($field['type'] == 'varchar' || $field['type'] == 'char') {
+    unset($field['length']);
+  }
+
+  return $field;
+}
+
+
+/**
+ * Create an SQL string for a field to be used in table creation or alteration.
+ *
+ * Before passing a field out of a schema definition into this function it has
+ * to be processed by _db_process_field().
+ *
+ * @param $name
+ *    Name of the field.
+ * @param $spec
+ *    The field specification, as per the schema data structure format.
+ */
+function _db_create_field_sql($name, $spec) {
+  $sql = '['. $name .'] '. $spec['sqlite_type'];
+
+  if (!empty($spec['auto_increment'])) {
+    $sql .= ' PRIMARY KEY AUTOINCREMENT';
+    return $sql;
+  }
+
+  if (!empty($spec['unsigned'])) {
+    $sql .= " CHECK ([$name] >= 0)";
+  }
+
+  if (!empty($spec['length'])) {
+    $sql .= '('. $spec['length'] .')';
+  }
+  elseif (isset($spec['precision']) && isset($spec['scale'])) {
+    $sql .= '('. $spec['precision'] .', '. $spec['scale'] .')';
+  }
+
+  if (isset($spec['not null']) && $spec['not null']) {
+    $sql .= ' NOT NULL';
+  }
+
+  if (isset($spec['default'])) {
+    $default = is_string($spec['default']) ? "'". $spec['default'] ."'" : $spec['default'];
+    $sql .= " DEFAULT $default";
+  }
+
+  return $sql;
+}
+
+
+/**
+ * Returns the SQL needed to add a primary key
+ */
+function _db_create_keys_sql($spec) {
+  $keys = array();
+
+  if (!empty($spec['primary key'])) {
+    $keys[] = 'PRIMARY KEY ('. _db_create_key_sql($spec['primary key']) .')';
+  }
+
+  return $keys;
+}
+
+
+/**
+ * Returns the SQL needed to add a single key
+ */
+function _db_create_key_sql($fields) {
+  $ret = array();
+  foreach ($fields as $field) {
+    if (is_array($field)) {
+      $ret[] = $field[0]; // .'('. $field[1] .')';
+    }
+    else {
+      $ret[] = $field;
+    }
+  }
+  return implode(', ', $ret);
+}
+
+
+/**
+ * This maps a generic data type in combination with its data size
+ * to the engine-specific data type.
+ */
+function db_type_map() {
+  // Put :normal last so it gets preserved by array_flip.  This makes
+  // it much easier for modules (such as schema.module) to map
+  // database types back into schema types.
+  $map = array(
+    'varchar:normal'  => 'TEXT',
+    'char:normal'     => 'TEXT',
+
+    'text:tiny'       => 'TEXT',
+    'text:small'      => 'TEXT',
+    'text:medium'     => 'TEXT',
+    'text:big'        => 'TEXT',
+    'text:normal'     => 'TEXT',
+
+    'serial:tiny'     => 'INTEGER',
+    'serial:small'    => 'INTEGER',
+    'serial:medium'   => 'INTEGER',
+    'serial:big'      => 'INTEGER',
+    'serial:normal'   => 'INTEGER',
+
+    'int:tiny'        => 'INTEGER',
+    'int:small'       => 'INTEGER',
+    'int:medium'      => 'INTEGER',
+    'int:big'         => 'INTEGER',
+    'int:normal'      => 'INTEGER',
+
+    'float:tiny'      => 'REAL',
+    'float:small'     => 'REAL',
+    'float:medium'    => 'REAL',
+    'float:big'       => 'REAL',
+    'float:normal'    => 'REAL',
+
+    'numeric:normal'  => 'NUMERIC',
+
+    'blob:big'        => 'BLOB',
+    'blob:normal'     => 'BLOB',
+
+    'datetime:normal' => 'TEXT',
+  );
+  return $map;
+}
+
+
+/**
+ * Rename a table.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be renamed.
+ * @param $new_name
+ *   The new name for the table.
+ */
+function db_rename_table(&$ret, $table, $new_name) {
+  $ret[] = update_sql('ALTER TABLE {'. $table .'} RENAME TO {'. $new_name .'}');
+}
+
+
+/**
+ * Drop a table.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be dropped.
+ */
+function db_drop_table(&$ret, $table) {
+  $ret[] = update_sql('DROP TABLE {'. $table .'}');
+}
+
+
+/**
+ * Add a new field to a table.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   Name of the table to be altered.
+ * @param $field
+ *   Name of the field to be added.
+ * @param $spec
+ *   The field specification array, as taken from a schema definition.
+ *   The specification may also contain the key 'initial', the newly
+ *   created field will be set to the value of the key in all rows.
+ *   This is most useful for creating NOT NULL columns with no default
+ *   value in existing tables.
+ * @param $keys_new
+ *   Optional keys and indexes specification to be created on the
+ *   table along with adding the field. The format is the same as a
+ *   table specification but without the 'fields' element.  If you are
+ *   adding a type 'serial' field, you MUST specify at least one key
+ *   or index including it in this array. @see db_change_field for more
+ *   explanation why.
+ */
+function db_add_field(&$ret, $table, $field, $spec, $keys_new = array()) {
+  $fixnull = FALSE;
+  if (!empty($spec['not null']) && !isset($spec['default'])) {
+    $fixnull = TRUE;
+    $spec['not null'] = FALSE;
+  }
+  $query = 'ALTER TABLE {'. $table .'} ADD ';
+  $query .= _db_create_field_sql($field, _db_process_field($spec));
+  if (count($keys_new)) {
+    $query .= ', ADD '. implode(', ADD ', _db_create_keys_sql($keys_new));
+  }
+  $ret[] = update_sql($query);
+  if (isset($spec['initial'])) {
+    // All this because update_sql does not support %-placeholders.
+    $sql = 'UPDATE {'. $table .'} SET '. $field .' = '. db_type_placeholder($spec['type']);
+    $result = db_query($sql, $spec['initial']);
+    $ret[] = array('success' => $result !== FALSE, 'query' => check_plain($sql .' ('. $spec['initial'] .')'));
+  }
+  if ($fixnull) {
+    $spec['not null'] = TRUE;
+    db_change_field($ret, $table, $field, $field, $spec);
+  }
+}
+
+
+/**
+ * Drop a field.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $field
+ *   The field to be dropped.
+ */
+function db_drop_field(&$ret, $table, $field) {
+  $new_schema = _db_introspectSchema($table);
+  unset($new_schema['fields'][$field]);
+  foreach ($new_schema['indexes'] as $index => $fields) {
+    foreach ($fields as $key => $field_name) {
+      if ($field_name == $field) {
+        unset($new_schema['indexes'][$index][$key]);
+      }
+    }
+    // If this index has no more fields then remove it.
+    if (empty($new_schema['indexes'][$index])) {
+      unset($new_schema['indexes'][$index]);
+    }
+  }
+  _db_alterTable($ret, $table, $new_schema);
+}
+
+
+/**
+ * Set the default value for a field.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $field
+ *   The field to be altered.
+ * @param $default
+ *   Default value to be set. NULL for 'default NULL'.
+ */
+function db_field_set_default(&$ret, $table, $field, $default) {
+  throw ("db_field_set_default Unsupported");
+}
+
+
+/**
+ * Set a field to have no default value.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $field
+ *   The field to be altered.
+ */
+function db_field_set_no_default(&$ret, $table, $field) {
+  throw ("db_field_set_no_default Unsupported");
+}
+
+
+/**
+ * Add a primary key.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $fields
+ *   Fields for the primary key.
+ */
+function db_add_primary_key(&$ret, $table, $fields) {
+  $schema = _db_introspectSchema($table);
+  $schema['primary key'] = $fields;
+  _db_alterTable($ret, $table, $schema);
+}
+
+
+/**
+ * Drop the primary key.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ */
+function db_drop_primary_key(&$ret, $table) {
+  $schema = _db_introspectSchema($table);
+  unset($schema['primary key']);
+  _db_alterTable($ret, $table, $schema);
+}
+
+
+/**
+ * Add a unique key.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $name
+ *   The name of the key.
+ * @param $fields
+ *   An array of field names.
+ */
+function db_add_unique_key(&$ret, $table, $name, $fields) {
+  $sql = _db_create_index_sql($table, $name, $fields, true);
+  $ret[] = update_sql($sql);
+}
+
+
+/**
+ * Drop a unique key.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $name
+ *   The name of the key.
+ */
+function db_drop_unique_key(&$ret, $table, $name) {
+  $sql = _db_drop_index_sql($table, $name);
+  $ret[] = update_sql($sql);
+}
+
+
+/**
+ * Add an index.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $name
+ *   The name of the index.
+ * @param $fields
+ *   An array of field names.
+ */
+function db_add_index(&$ret, $table, $name, $fields) {
+  $sql = _db_create_index_sql($table, $name, $fields, false);
+  $ret[] = update_sql($sql);
+}
+
+
+/**
+ * Drop an index.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   The table to be altered.
+ * @param $name
+ *   The name of the index.
+ */
+function db_drop_index(&$ret, $table, $name) {
+  $sql = _db_drop_index_sql($table, $name);
+  $ret[] = update_sql($sql);
+}
+
+
+/**
+ * Change a field definition.
+ *
+ * IMPORTANT NOTE: To maintain database portability, you have to explicitly
+ * recreate all indices and primary keys that are using the changed field.
+ *
+ * That means that you have to drop all affected keys and indexes with
+ * db_drop_{primary_key,unique_key,index}() before calling db_change_field().
+ * To recreate the keys and indices, pass the key definitions as the
+ * optional $keys_new argument directly to db_change_field().
+ *
+ * For example, suppose you have:
+ * @code
+ * $schema['foo'] = array(
+ *   'fields' => array(
+ *     'bar' => array('type' => 'int', 'not null' => TRUE)
+ *   ),
+ *   'primary key' => array('bar')
+ * );
+ * @endcode
+ * and you want to change foo.bar to be type serial, leaving it as the
+ * primary key.  The correct sequence is:
+ * @code
+ * db_drop_primary_key($ret, 'foo');
+ * db_change_field($ret, 'foo', 'bar', 'bar',
+ *   array('type' => 'serial', 'not null' => TRUE),
+ *   array('primary key' => array('bar')));
+ * @endcode
+ *
+ * The reasons for this are due to the different database engines:
+ *
+ * On PostgreSQL, changing a field definition involves adding a new field
+ * and dropping an old one which* causes any indices, primary keys and
+ * sequences (from serial-type fields) that use the changed field to be dropped.
+ *
+ * On MySQL, all type 'serial' fields must be part of at least one key
+ * or index as soon as they are created.  You cannot use
+ * db_add_{primary_key,unique_key,index}() for this purpose because
+ * the ALTER TABLE command will fail to add the column without a key
+ * or index specification.  The solution is to use the optional
+ * $keys_new argument to create the key or index at the same time as
+ * field.
+ *
+ * You could use db_add_{primary_key,unique_key,index}() in all cases
+ * unless you are converting a field to be type serial. You can use
+ * the $keys_new argument in all cases.
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   Name of the table.
+ * @param $field
+ *   Name of the field to change.
+ * @param $field_new
+ *   New name for the field (set to the same as $field if you don't want to change the name).
+ * @param $spec
+ *   The field specification for the new field.
+ * @param $keys_new
+ *   Optional keys and indexes specification to be created on the
+ *   table along with changing the field. The format is the same as a
+ *   table specification but without the 'fields' element.
+ */
+function db_change_field(&$ret, $table, $field, $field_new, $spec, $keys_new = array()) {
+  $schema = _db_introspectSchema($table);
+  if(isset($schema['fields'][$field])){
+    if ($field !== $field_new){
+      unset($schema['fields'][$field]);
+      $schema['fields'][$field_new] = $spec;
+    } else {
+      $schema['fields'][$field] = $spec;
+    }
+    _db_alterTable($ret, $table, $schema);
+  }
+}
+
+
+/**
+ * Returns the last insert id.
+ *
+ * @param $table
+ *   The name of the table you inserted into.
+ * @param $field
+ *   The name of the autoincrement field.
+ */
+function db_last_insert_id($table, $field) {
+  return db_result(db_query('SELECT last_insert_rowid()'));
+}
+
+
+/**
+ * Create a table with a new schema containing the old content.
+ *
+ * As SQLite does not support ALTER TABLE (with a few exceptions) it is
+ * necessary to create a new table and copy over the old content, then
+ * swap them and delete the original.
+ *
+ * Thanks to Dmitri Schamschurko for his precious feedback and help!
+ *
+ * @param $ret
+ *   Array to which query results will be added.
+ * @param $table
+ *   Name of the table to be altered.
+ * @param $new_schema
+ *   The new schema array for the table.
+ */
+function _db_alterTable(&$ret, $table, $new_schema) {
+
+  global $active_db;
+
+  // begin transaction
+  $active_db->beginTransaction();
+
+  // new table name
+  $i = 0;
+  do {
+    $new_table = $table . '_' . $i++;
+  } while (db_table_exists($new_table));
+
+  // we have an unique table name, let's retrieve SQL commands
+  // to create the new table.
+  $create_statements = db_create_table_sql($new_table, $new_schema);
+
+  /**
+   * the array $sql_statements is filled like this:
+   * [0]        BEGIN
+   * [1]        CREATE TABLE ...
+   * [.]        CREATE INDEX 1 ...
+   * [.]        CREATE INDEX 2 ...
+   * [.]        ...
+   * [count-1]  COMMIT
+   *
+   * now we need to create the table only and not all of its indexes
+   * otherwise they will be created with wrong names:
+   * suppose we are altering table 'my_table' with an index on field 'nid',
+   * the temporary table will be 'my_table_0' with index 'my_table_0_nid_IDX'.
+   *
+   * Indexes will then be recreated at the end of
+   * CREATE/SWAP/DELETE procedure.
+   */
+
+  // the 2nd statement is 'CREATE TABLE', we run it alone
+  $ret[] = update_sql($create_statements[1]);
+
+  // copy the original data into the new (temp) table
+  $fields = implode(', ', array_keys($new_schema['fields']));
+  $ret[] = update_sql('INSERT INTO {' . $new_table . "} ($fields) SELECT $fields FROM {" . $table . '}');
+
+  // test if table copy suceeded for all the source rows
+  $old_count = db_query('SELECT COUNT(*) FROM {' . $table . '}')->fetchColumn();
+  $new_count = db_query('SELECT COUNT(*) FROM {' . $new_table . '}')->fetchColumn();
+  if ($old_count !== false && $old_count == $new_count) {
+    // swap the two tables: original -> temp, new->original, drop temp
+    do {
+      $temp_table = $table . '_' . $i++;
+    } while (db_table_exists($temp_table));
+    db_rename_table($ret, $table, $temp_table);
+    db_rename_table($ret, $new_table, $table);
+    db_drop_table($ret, $temp_table);
+
+    // recreate table indexes
+    if (isset($new_schema['indexes']) && is_array($new_schema['indexes'])) {
+      foreach ($new_schema['indexes'] as $key_name => $key) {
+        db_add_index($ret, $table, $key_name, $key);
+      }
+    }
+  } else {
+    // ask to rollback transaction
+    $ret[] = array('success' => FALSE,
+                   'query' => 'ALTER TABLE: Failed to copy data.'
+                  );
+  }
+
+  // test for success before committing
+  foreach($ret as $i) {
+    if(!$i['success']) {
+      // rollback transaction
+      $active_db->rollback();
+      return;
+    }
+  }
+
+  // commit transaction
+  $active_db->commit();
+
+}
+
+/**
+ * Find out the schema of a table.
+ *
+ * This function uses introspection methods provided by the database to
+ * create a schema array. This is useful, for example, during update when
+ * the old schema is not available.
+ *
+ * @param $table
+ *   Name of the table.
+ * @return
+ *   An array representing the schema, @see drupal_get_schema.
+ */
+function _db_introspectSchema($table) {
+  $mapped_fields = array_flip(db_type_map());
+  $schema = array();
+  $stmt = db_query("PRAGMA table_info('{" . $table . "}')");
+  while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+    if (preg_match('/^([^(]+)\((.*)\)$/', $row['type'], $matches)) {
+      $type = $matches[1];
+      $length = $matches[2];
+    }
+    else {
+      $type = $row['type'];
+      $length = NULL;
+    }
+    if (isset($mapped_fields[$type])) {
+      list($type, $size) = explode(':', $mapped_fields[$type]);
+      $schema['fields'][$row['name']] = array(
+          'type' => $type,
+          'size' => $size,
+          'not null' => !empty($row['notnull']),
+          'default' => trim($row['dflt_value'], "'"),
+      );
+      if ($length) {
+        $schema['fields'][$row['name']]['length'] = $length;
+      }
+      if ($row['pk']) {
+        $schema['primary key'][] = $row['name'];
+      }
+    }
+    else {
+      new Exception("Unable to parse the column type " . $row['type']);
+    }
+  }
+
+  $indexes = array();
+  $stmt = db_query("PRAGMA index_list('{" . $table . "}')");
+  while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+    if (strpos($row['name'], 'sqlite_autoindex_') !== 0) {
+      $indexes[] = array(
+          'schema_key' => $row['unique'] ? 'unique keys' : 'indexes',
+          'name' => $row['name'],
+      );
+    }
+  }
+
+  $n = strlen($table) + 1;
+  foreach ($indexes as $index) {
+    $name = $index['name'];
+    // drop out index name prefix ("TableName_") and suffix ("_IDX")
+    $index_name = substr($name, $n, - strlen(SQLITE_INDEX_NAME_SUFFIX));
+    $stmt = db_query("PRAGMA index_info('$name')");
+    while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
+      $schema[$index['schema_key']][$index_name][] = $row['name'];
+    }
+  }
+  return $schema;
+}
+
+
+
+/**
+ * User defined functions to replace the ones missing in SQLite.
+ */
+function _sqlite_concat() {
+  $a = func_get_args();
+  return implode('', $a);
+}
+
+function _sqlite_substring() {
+  $a = func_get_args();
+  return substr($a[0], $a[1] - 1, $a[2]);
+}
+
+function _sqlite_year($date) {
+  return date("Y", strtotime($date));
+}
+
+function _sqlite_month($date) {
+  return date("m", strtotime($date));
+}
+
+function _sqlite_from_unix_timestamp($timestamp) {
+  //YYYY-MM-DD HH:MM:SS
+  return date("Y-m-d G:i:s", $timestamp);
+}
+
+function _sqlite_pow($num, $exp) {
+  return pow($num, $exp);
+}
+
+function _sqlite_greatest() {
+  $a = func_get_args();
+  return max($a);
+}
+
+/* COALESCE (MySQL) */
+function _sqlite_coalesce_step(&$context, $rownumber, $value) {
+  if($value !== null)
+  return $value;
+  return null;
+}
+function _sqlite_coalesce_finalize(&$context, $rownumber) {
+  return $context;
+}
+
+/* Standard deviation STDDEV (MySQL) */
+function _sqlite_stddev_step(&$context, $rownumber, $value) {
+  if (!$context)
+    return array(
+                'mean' => (float) $value,
+                'quad' => (float) $value * (float) $value,
+                'cnt' => 1,
+                );
+
+  $context['mean'] += (float) $value;
+  $context['quad'] += (float) $value * (float) $value;
+  $context['cnt']  += 1;
+
+  return $context;
+}
+
+function _sqlite_stddev_finalize(&$context, $rownumber) {
+  if ($context['cnt'])
+  {
+    return sqrt(($context['quad'] - $context['mean'] * $context['mean'] / (float) $context['cnt']) / (float) $context['cnt']);
+  }
+
+  return 0.0;
+}
+
+
+function _sqlite_rand() {
+  return rand();
+}
+
+function _sqlite_if($expr, $true_part, $false_part) {
+  if ($expr)
+  return ($true_part);
+  else
+  return ($false_part);
+}
+
+function _sqlite_md5($text) {
+  return md5($text);
+}
+
+function _sqlite_dateformat($date, $format) {
+  if($date) {
+    list($year, $month, $day) = explode('-', $date) ;
+    return(strftime($format,mktime(0,0,0,(int)$month,(int)$day,(int)$year))) ;
+  } else {
+    return null;
+  }
+}
\ No newline at end of file
diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/includes/database.sqlite.user-patches.sample drupal-sqlite/includes/database.sqlite.user-patches.sample
--- drupal-6.19/includes/database.sqlite.user-patches.sample	1970-01-01 01:00:00.000000000 +0100
+++ drupal-sqlite/includes/database.sqlite.user-patches.sample	2009-12-17 13:16:17.448625000 +0100
@@ -0,0 +1,33 @@
+<?php
+/**
+ * ======================================================================
+ * This file is a sample to help writing your custom query rewrite rules.
+ * Rename the file to "database.sqlite.user-patches.inc"
+ * and your rules will be applied AFTER the core ones.
+ * 
+ * $query is a String parameter that contains
+ * the SQL query ready to be executed.
+ * ======================================================================
+ */
+function _sqlite_user_rewrite_query(&$query)
+{
+
+  /**
+   * ------------------------------------------
+   * First rule: only a sample, remove it!
+   * ------------------------------------------
+   */
+  if (stripos($query, 'SELECT ') === 0){
+    $query = 'THIS_IS_ONLY_A_SAMPLE_REMOVE_ME_AND_ADD_YOUR_RULES ' . $query;
+  }
+  
+  /**
+   * ------------------------------------------
+   * Second rule: only a sample, remove it!
+   * ------------------------------------------
+   */
+  if(variable_get('my_variable', 0)) {
+    // ... rewrite logic here ...
+  }
+  
+}
\ No newline at end of file
diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/includes/install.inc drupal-sqlite/includes/install.inc
--- drupal-6.19/includes/install.inc	2009-02-16 11:25:02.000000000 +0100
+++ drupal-sqlite/includes/install.inc	2009-02-16 11:25:02.000000000 +0100
@@ -152,7 +152,11 @@
 function drupal_detect_database_types() {
   $databases = array();
 
-  foreach (array('mysql', 'mysqli', 'pgsql') as $type) {
+  // ----- SQLite patch -----
+  // added 'sqlite' as new available database type
+  // foreach (array('sqlite', 'mysql', 'mysqli', 'pgsql') as $type) {
+  foreach (array('sqlite', 'mysql', 'mysqli', 'pgsql') as $type) {
+  // ----- End of SQLite patch -----
     if (file_exists('./includes/install.'. $type .'.inc')) {
       include_once './includes/install.'. $type .'.inc';
       $function = $type .'_is_available';
diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/includes/install.sqlite.inc drupal-sqlite/includes/install.sqlite.inc
--- drupal-6.19/includes/install.sqlite.inc	1970-01-01 01:00:00.000000000 +0100
+++ drupal-sqlite/includes/install.sqlite.inc	2009-12-17 13:16:17.558000000 +0100
@@ -0,0 +1,130 @@
+<?php
+// $Id:
+
+/**
+ * SQLite specific install functions
+ *
+ * This file is part of Drupal-SQLite by CoolSoft,
+ * a patched Drupal 6 version that works with a SQLite database layer.
+ *
+ * @author Claudio Nicora (coolsoft@altervista.org)
+ * @see http://coolsoft.altervista.org/drupal-sqlite
+ */
+
+/**
+ * Check if SQLite is available.
+ *
+ * @return
+ *  TRUE/FALSE
+ */
+function sqlite_is_available() {
+  return class_exists('PDO') && extension_loaded('pdo_sqlite');
+}
+
+/**
+ * Check if we can connect to SQLite.
+ *
+ * @return boolean
+ *  TRUE/FALSE
+ */
+function drupal_test_sqlite($url, &$success) {
+
+  if (!sqlite_is_available()) {
+    drupal_set_message(st('PHP SQLite support not enabled.'), 'error');
+    return FALSE;
+  }
+
+  // we are interested only to path component, removing the leading "/"
+ 	$url = parse_url(urldecode($url));
+ 	if (!isset($url['path'])) {
+ 	  drupal_set_message(st('Failed to parse SQLite database path.'));
+ 	  return FALSE;
+ 	} else {
+ 	  $url = substr($url['path'], 1);
+ 	}
+
+ 	// test if user set an absolute path.
+ 	// in this case we have another leading "/"
+ 	if (substr($url['path'], 0, 1) === '/') {
+ 	  drupal_set_message('Database path must be relative (not starting with /), like "sites/default/db.s3db"');
+ 	  return FALSE;
+ 	}
+
+ 	// now $url contains the relative path to the db file
+ 	// let's test if it exists
+ 	$path = dirname($url);
+  if(!is_dir($path)) {
+    // create the folder
+    mkdir($path, 0777, true);
+    // create an .htaccess file to prevent DB file download
+    $path_info = pathinfo($url);
+    $file_ext = $path_info['extension'];
+    $htfile = <<<EOF
+<FilesMatch "\.${file_ext}$">
+  Order allow,deny
+</FilesMatch>
+EOF;
+    file_put_contents("$path/.htaccess", $htfile);
+ 	}
+
+  // create .htaccess file
+  $path = dirname($url);
+  if(!is_dir($path)) {
+    // create the folder
+    mkdir($path, 0777, true);
+  }
+
+ 	// test access permission to database folder
+ 	if(!is_writable($path)) {
+    drupal_set_message('Drupal-SQLite needs read/write access both to database
+    file and the folder containing it.
+    <br/>Folder '.$path.' is not writable.
+    <br/>Please fix permissions and retry.',
+    'error');
+    return FALSE;
+ 	}
+
+ 	// Build pdo_sqlite connection string.
+ 	$dsn = 'sqlite:' . $url;
+
+ 	$driver_options = array(
+ 	// Throw a PDOException and set its properties to reflect the error code
+ 	// and error information.
+ 	PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
+ 	//  Leave column names as returned by the database driver.
+ 	PDO::ATTR_CASE => PDO::CASE_NATURAL,
+ 	);
+
+ 	// Test connecting to the database.
+ 	// This will create the DB if it doesn't exist.
+ 	$connection = new PDO($dsn, '', '', $driver_options);
+ 	if (!$connection) {
+ 	  drupal_set_message(st('Failed to connect to your SQLite database. SQLite reports the following message: %error.', array('%error' => sqlite_install_db_error())), 'error');
+ 	  return FALSE;
+ 	}
+ 	$success = array('CONNECT');
+
+ 	// Since SQLite has no permissions, once we successfully connected to the DB
+ 	// we could skip SELECT/CREATE/INSERT/UPDATE/DROP tests
+ 	$success[] = 'SELECT';
+ 	$success[] = 'CREATE';
+ 	$success[] = 'INSERT';
+ 	$success[] = 'UPDATE';
+ 	$success[] = 'DELETE';
+ 	$success[] = 'DROP';
+
+ 	// return True
+ 	return TRUE;
+}
+
+
+/**
+ * Returns a formatted error message
+ */
+function sqlite_install_db_error($stmt) {
+  $error = $stmt->errorInfo();
+  if (is_array($error) && isset($error[2])) {
+    return $error[2];
+  }
+  return false;
+}
diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/install.php drupal-sqlite/install.php
--- drupal-6.19/install.php	2010-05-09 16:13:31.000000000 +0200
+++ drupal-sqlite/install.php	2010-03-05 09:11:45.255250000 +0100
@@ -1,5 +1,5 @@
 <?php
-// $Id: install.php,v 1.113.2.12 2010/05/09 14:13:31 dries Exp $
+// $Id: install.php,v 1.113.2.9 2009/04/27 10:50:35 goba Exp $
 
 require_once './includes/install.inc';
 
@@ -257,6 +257,23 @@
       }
     }
 
+    // ----- SQLite patch -----
+    // additional help for SQLite databases
+    $temp_desc = <<<EOF
+*** SQLite database: ***
+|Insert the filename that will contain your database,
+with relative path (default is "sites/default/db/db.s3db").
+|The folder will be created if it not exists.
+|Database username field below can contain anything (it won't be used).
+|*** Other databases: ***
+|
+EOF;
+    $db_path_description = str_replace('|', '<br/>', $temp_desc).$db_path_description;
+    // default values
+    $db_path = 'sites/default/db/db.s3db';
+    $db_user = 'coolsoft';
+    // ----- End of SQLite patch -----
+    
     // Database name
     $form['basic_options']['db_path'] = array(
       '#type' => 'textfield',
diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/profiles/drupal_sqlite/drupal_sqlite.profile drupal-sqlite/profiles/drupal_sqlite/drupal_sqlite.profile
--- drupal-6.19/profiles/drupal_sqlite/drupal_sqlite.profile	1970-01-01 01:00:00.000000000 +0100
+++ drupal-sqlite/profiles/drupal_sqlite/drupal_sqlite.profile	2009-12-17 13:16:09.464250000 +0100
@@ -0,0 +1,231 @@
+<?php
+// $Id:
+
+/**
+ * Installation profile for Drupal-SQLite
+ *
+ * This file is part of Drupal-SQLite by CoolSoft,
+ * a patched Drupal 6 version that works with a SQLite database layer.
+ *
+ * @author Claudio Nicora (coolsoft@altervista.org)
+ * @see http://coolsoft.altervista.org/drupal-sqlite
+ */
+
+/**
+ * Return an array of the modules to be enabled when this profile is installed.
+ *
+ * @return
+ *   An array of modules to enable.
+ */
+function drupal_sqlite_profile_modules() {
+  // time-consuming modules (dblog and syslog) are not enabled
+  return array('color', 'comment', 'help', 'menu', 'taxonomy');
+}
+
+/**
+ * Return a description of the profile for the initial installation screen.
+ *
+ * @return
+ *   An array with keys 'name' and 'description' describing this profile,
+ *   and optional 'language' to override the language selection for
+ *   language-specific profiles.
+ */
+function drupal_sqlite_profile_details() {
+
+  // default description
+  $desc = 'Select this profile to install Drupal with a SQLite database backend '
+      . 'and optimize it by removing all time-consuming modules (like dblog).';
+
+  // test requirements
+  $requirements = drupal_sqlite_profile_test_requirements();
+
+  // count failed requirements
+  $failed = 0;
+  foreach($requirements as $req => $value) {
+    if (!$value['ok']) $failed +=1;
+  }
+
+  if($failed) {
+    $desc .= <<< EOF
+<br/><br/><div class="error">WARNING:
+Drupal-SQLite won't work because one of the following requirements
+is not satisfied; please fix it and refresh this page to retry.
+</div>
+EOF;
+    $desc .= '<ul>';
+    foreach($requirements as $req => $value) {
+      $desc .= '<li><img src="misc/'
+        . ($value['ok'] ? 'watchdog-ok.png' : 'watchdog-error.png')
+        . '">&nbsp;'
+        . $value['description'].'</li>';
+    }
+    $desc .= '</ul>';
+  } else {
+    $desc .= '<br/>In the next screen <b><u>choose "sqlite" as database type</b></u> and fill the required fields.';
+  }
+
+  return array(
+    'name' => 'Drupal-SQLite',
+    'description' => $desc,
+    );
+}
+
+/**
+ * Return a list of tasks that this profile supports.
+ *
+ * @return
+ *   A keyed array of tasks the profile will perform during
+ *   the final stage. The keys of the array will be used internally,
+ *   while the values will be displayed to the user in the installer
+ *   task list.
+ */
+function drupal_sqlite_profile_task_list() {
+}
+
+/**
+ * Perform any final installation tasks for this profile.
+ *
+ * The installer goes through the profile-select -> locale-select
+ * -> requirements -> database -> profile-install-batch
+ * -> locale-initial-batch -> configure -> locale-remaining-batch
+ * -> finished -> done tasks, in this order, if you don't implement
+ * this function in your profile.
+ *
+ * If this function is implemented, you can have any number of
+ * custom tasks to perform after 'configure', implementing a state
+ * machine here to walk the user through those tasks. First time,
+ * this function gets called with $task set to 'profile', and you
+ * can advance to further tasks by setting $task to your tasks'
+ * identifiers, used as array keys in the hook_profile_task_list()
+ * above. You must avoid the reserved tasks listed in
+ * install_reserved_tasks(). If you implement your custom tasks,
+ * this function will get called in every HTTP request (for form
+ * processing, printing your information screens and so on) until
+ * you advance to the 'profile-finished' task, with which you
+ * hand control back to the installer. Each custom page you
+ * return needs to provide a way to continue, such as a form
+ * submission or a link. You should also set custom page titles.
+ *
+ * You should define the list of custom tasks you implement by
+ * returning an array of them in hook_profile_task_list(), as these
+ * show up in the list of tasks on the installer user interface.
+ *
+ * Remember that the user will be able to reload the pages multiple
+ * times, so you might want to use variable_set() and variable_get()
+ * to remember your data and control further processing, if $task
+ * is insufficient. Should a profile want to display a form here,
+ * it can; the form should set '#redirect' to FALSE, and rely on
+ * an action in the submit handler, such as variable_set(), to
+ * detect submission and proceed to further tasks. See the configuration
+ * form handling code in install_tasks() for an example.
+ *
+ * Important: Any temporary variables should be removed using
+ * variable_del() before advancing to the 'profile-finished' phase.
+ *
+ * @param $task
+ *   The current $task of the install system. When hook_profile_tasks()
+ *   is first called, this is 'profile'.
+ * @param $url
+ *   Complete URL to be used for a link or form action on a custom page,
+ *   if providing any, to allow the user to proceed with the installation.
+ *
+ * @return
+ *   An optional HTML string to display to the user. Only used if you
+ *   modify the $task, otherwise discarded.
+ */
+function drupal_sqlite_profile_tasks(&$task, $url) {
+
+  // Insert default user-defined node types into the database. For a complete
+  // list of available node type attributes, refer to the node type API
+  // documentation at: http://api.drupal.org/api/HEAD/function/hook_node_info.
+  $types = array(
+  array(
+      'type' => 'page',
+      'name' => st('Page'),
+      'module' => 'node',
+      'description' => st("A <em>page</em>, similar in form to a <em>story</em>, is a simple method for creating and displaying information that rarely changes, such as an \"About us\" section of a website. By default, a <em>page</em> entry does not allow visitor comments and is not featured on the site's initial home page."),
+      'custom' => TRUE,
+      'modified' => TRUE,
+      'locked' => FALSE,
+      'help' => '',
+      'min_word_count' => '',
+    ),
+    array(
+      'type' => 'story',
+      'name' => st('Story'),
+      'module' => 'node',
+      'description' => st("A <em>story</em>, similar in form to a <em>page</em>, is ideal for creating and displaying content that informs or engages website visitors. Press releases, site announcements, and informal blog-like entries may all be created with a <em>story</em> entry. By default, a <em>story</em> entry is automatically featured on the site's initial home page, and provides the ability to post comments."),
+      'custom' => TRUE,
+      'modified' => TRUE,
+      'locked' => FALSE,
+      'help' => '',
+      'min_word_count' => '',
+    ),
+  );
+
+  foreach ($types as $type) {
+    $type = (object) _node_type_set_defaults($type);
+    node_type_save($type);
+  }
+
+  // Default page to not be promoted and have comments disabled.
+  variable_set('node_options_page', array('status'));
+  variable_set('comment_page', COMMENT_NODE_DISABLED);
+
+  // Don't display date and author information for page nodes by default.
+  $theme_settings = variable_get('theme_settings', array());
+  $theme_settings['toggle_node_info_page'] = FALSE;
+  variable_set('theme_settings', $theme_settings);
+
+  // Update the menu router information.
+  menu_rebuild();
+}
+
+/**
+ * Implementation of hook_form_alter().
+ *
+ * Allows the profile to alter the site-configuration form. This is
+ * called through custom invocation, so $form_state is not populated.
+ */
+function drupal_sqlite_form_alter(&$form, $form_state, $form_id) {
+
+  if ($form_id == 'install_configure') {
+
+    // Add some default values
+    $form['site_information']['site_name']['#default_value'] = 'Drupal-SQLite';
+    $form['admin_account']['account']['name']['#default_value'] = 'administrator';
+
+  }
+
+}
+
+
+/**
+ * Test installation requirements
+ * @return array
+ */
+function drupal_sqlite_profile_test_requirements() {
+
+  $res = array();
+
+  // PHP version (different from Drupal)
+  $min_php_ver = "5.2.0";
+  $res['sqlite-php-version'] = array(
+    'description' => "Minimum PHP version: required $min_php_ver, found: ".phpversion(),
+    'ok'   => (version_compare(phpversion(), $min_php_ver) >= 0),
+  );
+
+  // Test SQLite patch
+  $res['sqlite-patch'] = array(
+    'description' => 'Patch to run Drupal on a SQLite database',
+    'ok'   => file_exists('includes/database.sqlite.inc'),
+  );
+
+  // test for PDO_SQLite support
+  $res['sqlite-support'] = array(
+    'description' => 'PHP PDO_SQLite support',
+    'ok'   => class_exists('PDO') && extension_loaded('pdo_sqlite'),
+  );
+
+  return $res;
+}
\ No newline at end of file
diff -Naur --ignore-file-name-case -X drupal-sqlite.excludedFiles drupal-6.19/README.sqlite.txt drupal-sqlite/README.sqlite.txt
--- drupal-6.19/README.sqlite.txt	1970-01-01 01:00:00.000000000 +0100
+++ drupal-sqlite/README.sqlite.txt	2010-08-12 22:39:02.456539800 +0200
@@ -0,0 +1,271 @@
+// $Id:
+
+WHAT IS DRUPAL-SQLITE ?
+=======================
+Drupal-SQLite is a project to make Drupal 6 work with a SQLite database.
+
+SQLite is a lightweight, fast, public domain, easily integrable,
+multiplatform database system. It's used by many greatest
+open source projects; just to name one... Mozilla Foudation on
+their Firefox & Thunderbird.
+
+Why should I need this?
+Well, most hosting providers gives you PHP 5.2+ for free,
+but they ask a few bucks for a MySQL database.
+If this could worth the case for mid-large sites, with hundreds or
+thousands users a day, it's a waste for mid-small sites.
+
+
+REQUIREMENTS
+============
+Drupal-SQLite requires PHP 5.2+ with PDO-SQLite support enabled.
+WARNING: PDO-SQLite is NOT the standard SQLite support (non-PDO) and
+should be built into your PHP or (usually) provided by an external
+extension named php_pdo_sqlite.dll (win) or php_pdo_sqlite.so (linux).
+
+To test if PDO_SQLite support is enabled create a text file,
+name it phpinfo.php and insert a single line:
+
+<?php phpinfo(); ?>
+
+Now open this file in your browser and check if a section
+named "pdo_sqlite" exists and is enabled.
+
+NOTE to Windows XAMPP users:
+XAMPP 1.7.0 comes with pdo_sqlite disabled by default.
+To enable it:
+* open C:\xampp\apache\bin\php.ini file
+* find the row containing
+  ;extension=php_pdo_sqlite.dll
+* remove the leading ";" to enable PDO-SQLite
+* restart Apache
+
+
+HOW TO INSTALL A NEW WEBSITE WITH SQLITE SUPPORT
+================================================
+Drupal-SQLite comes in two flavours:
+
+* Full archive
+  This should be the best solution for Windows based hosting,
+  but it surely works on Linux too.
+  Download the archive and extract it in your web server root folder.
+   
+* Patch file
+  Since applying patches on Windows is not so easy,
+  I suggest this to Linux users only.
+  Download patch file of the original Drupal version you're going to patch
+  and apply it to Drupal tree you already extracted to your web server
+  root folder. If the patch applied successfully then go on.
+	  
+In both cases you'll end with a patched Drupal source tree.
+
+Now you're ready to start installation: open /install.php in your browser
+and follow the instructions. Be careful to:
+
+* choose the "Drupal-SQLite" profile at the very first page to have
+  an optimized configuration.
+  This will disable time-consuming modules like, syslog and dblog.
+
+* select "sqlite" as database type inside the "basic options" block
+  (it should be the first available)
+
+* when asked for a database name, remember that this will be the
+  full (relative) path to your database file and not only the db name,
+  as it happens with mysql.
+  Default value is: sites/default/db/db.s3db
+
+* username is not used at all, but in Drupal installer this is a required
+  field; this is why it will be pre-filled with "coolsoft".
+
+
+SECURITY NOTES
+==============
+Your database is now a single file (by default sites/default/db/*.s3db),
+and you should protect it from being downloaded.
+Drupal-SQLite will create a preconfigured .htaccess files to deny access
+to *.s3db files. This file will be created by the setup procedure into
+the same folder which will contain the DB file.
+
+Please edit it if you changed proposed database file name, then test if it works.
+
+
+UPGRADE FROM PREVIOUS VERSIONS
+==============================
+* Full archive version
+  Download the archive of the new version and extract it into the
+  root folder of your Drupal setup, overwriting existing files.
+  Your website content will be preserved.
+
+* Patch file version
+  Update Drupal as you will do with a standard Drupal setup, then apply
+  the corresponding patch.
+
+
+ADDITIONAL ACTION AFTER UPGRADING FROM Drupal-SQLite-6.10-1.0 
+=============================================================
+If you are upgrading from Drupal-SQLite 1.0, please note that for security
+reasons, database file is now contained in a reserved subfolder.
+(see: http://coolsoft.altervista.org/en/drupal-sqlite#comment-40)
+
+If you previously let Drupal-SQLite 1.0 create the file in "sites/default/db.s3db",
+you should move it in a reserved folder like "sites/default/db/db.s3db".
+This folder must be read/writable by the webserver user.
+
+After doing this, open your config file (sites/default/settings.php), search
+a line like this (around line 92):
+  $db_url = 'sqlite://coolsoft@localhost/sites%2Fdefault%2Fdb.s3db';
+and edit it to make it link to the new DB location, like
+  $db_url = 'sqlite://coolsoft@localhost/sites%2Fdefault%2Fdb%2Fdb.s3db';
+
+NOTE: path separators "/" must be encoded as %2F.
+
+
+ACKNOWLEDGEMENTS
+================
+- Drupal team
+  Their CMS is great, even if it misses SQLite support ;)
+
+- Roberto Capuzzo (http://interdict.altervista.org)
+  He wrote a great italian tutorial on installing Drupal-SQLite on
+  Altervista WebHosting. The tutorial is here:
+  http://coolsoft.altervista.org/it/drupal-sqlite#ack
+  
+- Dmitri Schamschurko
+  He gave me a great feedback and help debugging SQLite
+  table schema functions in database.sqlite.inc. 
+  This lead to CCK module support in Drupal-SQLite-6.13-1.2
+
+
+CHANGELOG
+=========
+
+Drupal-SQLite-6.19-1.5, 2010-08-12
+----------------------------------
+- Drupal official version 6.19
+  INCLUDES SECURITY FIXES from Drupal 6.18 (see http://drupal.org/node/880476)
+  Includes bug fixes from Drupal 6.19 (see http://drupal.org/drupal-6.19)
+  
+  
+Drupal-SQLite-6.17-1.5, 2010-06-03
+----------------------------------
+- Drupal official version 6.17
+  No security fixes in this release, see http://drupal.org/drupal-6.17
+
+
+Drupal-SQLite-6.16-1.5, 2010-03-05
+----------------------------------
+- Drupal official version 6.16
+  This release fixes security vulnerabilities.
+  Sites are urged to upgrade immediately after reading the security announcement:
+  http://drupal.org/drupal-6.16
+  
+  NOTE: when you run update.php you could be warned that
+        the [semaphore] table is missing.
+		That's OK because the [semaphore] table will be created from
+		the "system module update #6054" that you're just going to run.
+
+
+Drupal-SQLite-6.15-1.5, 2010-01-07
+----------------------------------
+- Drupal official version 6.15
+
+- Optimized query rewriting by adding shortcut returns after
+  a successful rewrite.
+
+- New core rewrite rule for cache and update modules ("TRUNCATE TABLE" SQL commands)
+
+- Fixed an error during setup that causes install.php not using
+  the values of "Site Name" and "Administrator username" fields.
+  The default values were used instead.
+
+  
+Drupal-SQLite-6.14-1.4, 2009-10-04
+----------------------------------
+- Drupal official version 6.14
+
+- New query rewriting system: it allows Drupal-SQLite to rewrite
+  SQL queries just before their execution, without the needing to
+  patch (core) modules.
+  Rewrite rules are contained into two new files:
+  
+  * database.sqlite.core-patches.inc
+    this file is maintained by CoolSoft and will include
+    rewrite rules for core modules and for widely used ones ;) (like "devel")
+	
+  * database.sqlite.user-patches.inc (optional)
+    here you could add rewrite rules for all other modules
+  
+- Drupal DB functions "db_add_unique_key" and "db_remove_unique_key"
+  are now supported.
+
+- Workaround for SQLite not returning short column names for queries
+  with JOIN or GROUP BY clauses.
+  
+- Added support for SQL function STDDEV (thanks again Dmitri)
+
+
+Drupal-SQLite-6.13-1.3, 2009-08-06
+----------------------------------
+- Fixed a bug in _db_query function which causes multiple/nested queries to fail.
+
+  
+Drupal-SQLite-6.13-1.2, 2009-07-15
+----------------------------------
+- Bug fixing and code cleanup in SQLite table schema management
+  functions: db_column_exists, db_create_table_sql, _db_create_index_sql,
+  _db_alterTable, _db_introspectSchema.
+  Thanks to Dmitri Schamschurko for his great help and feedback.
+  
+- CCK module (cck-6.4-2.4) now works with Drupal-SQLite.
+
+
+Drupal-SQLite-6.13-1.1, 2009-07-02
+----------------------------------
+- Drupal official version 6.13
+
+
+Drupal-SQLite-6.12-1.1, 2009-05-14
+----------------------------------
+- Drupal official version 6.12
+  
+  
+Drupal-SQLite-6.11-1.1.1, 2009-05-09
+------------------------------------
+- This is only a repackage of the previous archive version, due to missing
+  folders in drupal-sqlite-6.11-1.1.zip file. Missing folders were:
+   /modules/color/images
+   /sites
+   /themes/garland/images
+	
+  I'm sorry for that <:) 
+
+
+Drupal-SQLite-6.11-1.1, 2009-05-05
+----------------------------------
+- Drupal official version 6.11
+
+- Increased length of database name field (which here is used as a path)
+
+- Moved new 'sqlite' database type as first in install.inc, so it
+  becomes the default selected during install
+  
+- The profile Drupal-SQLite now checks requirements during the install.
+  see: http://coolsoft.altervista.org/en/drupal-sqlite#comment-28
+  
+- Database file is now, by default, contained in a reserved folder.
+  SQLite needs RW access to both the database file and the containing folder.
+  see: http://coolsoft.altervista.org/en/drupal-sqlite#comment-40
+
+- Install procedure will now create both the database and its folder,
+  and test their permissions.
+  see: http://coolsoft.altervista.org/en/drupal-sqlite#comment-40
+  
+- Fixed usage of undeclared variables in includes/database.sqlite.inc
+  see: http://coolsoft.altervista.org/en/drupal-sqlite#comment-37
+
+
+Drupal-SQLite-6.10-1.0, 2009-03-21
+----------------------------------
+- Drupal official version 6.10
+
+- First public release
